#!/usr/bin/env node
/// dapp-quicktest -- run EVM tests using ethrun(1)

var PROGRAM_NAME = process.argv[1].replace(/.*\//, "")
var PROGRAM_ARGS = process.argv.slice(2)

var BigNumber = require("bignumber.js")
var ethabi = require("ethereumjs-abi")
var {sha3} = require("ethereumjs-util");

BigNumber.config({ DECIMAL_PLACES: 36 })

function keccak(hexdata) {
  return sha3(
    new Buffer(hexdata, "hex")
  ).toString("hex")
}

var classes = {}
var methods = {}
var addressNames = {}

// XXX side effects
// getAllClassesJSON().forEach(getClasses)

process.on("unhandledException", () => process.exit(1))

var inputFiles = []
var verbose = 0
var testRegex = new RegExp('^test')

for (var i = 0; i < PROGRAM_ARGS.length; i++) {
  var arg = PROGRAM_ARGS[i]
  if (/^(-v|--(verbose|report))$/.test(arg)) {
    verbose++
  } else if (/^(-r|--regex)$/.test(arg)) {
    next = PROGRAM_ARGS[i + 1]
    if (next !== undefined && !/^-/.test(next)) {
      testRegex = new RegExp(next)
      i++
    } else {
      console.error(`${PROGRAM_NAME}: ${arg} requires an argument`)
      process.exit(1)
    }
  } else if (/^-/.test(arg)) {
    console.error(`${PROGRAM_NAME}: unknown option: ${arg}`)
    process.exit(1)
  } else {
    inputFiles.push(arg)
  }
}

var classesJSON

if (inputFiles.length >= 1 && (
  require("fs").lstatSync(inputFiles[0]).isDirectory()
)) {
  classesJSON = {
    contracts: Object.assign({
    }, ...require("fs").readdirSync(inputFiles[0]).filter(x => {
      return /\.abi$/.test(x)
    }).map(x => {
      var filename = `${inputFiles[0]}/${x}`
      return {
        [x.replace(/\.abi$/, "")]: {
          abi: require("fs").readFileSync(
            filename, { encoding: "utf-8" }
          ),
          bin: require("fs").readFileSync(
            `${filename.replace(/abi$/, "bin")}`, { encoding: "utf-8" }
          ),
          "bin-runtime": require("fs").readFileSync(
            `${filename.replace(/abi$/, "bin-runtime")}`, {
              encoding: "utf-8"
            }
          ),
        }
      }
    }))
  }
} else {
  console.error(`${PROGRAM_NAME}: need to provide an input directory`)
}

// extra bytecode to deploy via ethrun
var extraBytecode = []
if (inputFiles.length > 1 && (
  require("fs").lstatSync(inputFiles[0]).isDirectory()
)) {
  const readBytes = f => require("fs").readFileSync(f, { encoding: "utf-8"})
  extraBytecode = inputFiles.slice(1).map(readBytes)
}

if (!getTestClasses().length) {
  console.log(`${PROGRAM_NAME}: no tests found`)
  process.exit(0)
}

var t0 = new Date
console.log(`Trying ${getTestClasses().map(x => x.name).join(", ")}...`)

var localSourceCode = getLocalSourceCode()
var allSourceCode = [localSourceCode].join("\n")

var events = getEvents()
var tests = getTests()

function formatEventDeclaration({ name, inputs, indexed }) {
  return `event ${name}(${inputs.map(({ type, indexed, name }) => {
    return `${type}${indexed ? " indexed" : ""} ${name}`
  }).join(", ")});`
}

function formatMethod({ name, inputs=[] }) {
  return `${name}(${inputs.map(({ type }) => type).join(",")})`
}

function scan(string, pattern) {
  var result = []
  string.replace(pattern, (...match) => result.push(match))
  return result
}

function getEvents() {
  return scan(
    allSourceCode, /\bevent\s+(\w+)\s*\(([\w\s,]*)\)\s*(anonymous\b)?/g
  ).map(([_, name, list, anonymous]) => ({
    type: "event", anonymous, name,
    inputs: list.split(/,/).map(
      x => x.trim().replace(/\s+/g, " ")
    ).map((item, i) => {
      var [type, ...words] = item.split(" ")
      var indexed = words.some(x => x == "indexed")
      var name = words.filter(x => x != "indexed")[0] || `param${i + 1}`
      return { type, indexed, name }
    })
  }))
}

tests.forEach(runTest)

function runTest(test) {
  var haveSetUp = test.class.members.some(x => x.name == "setUp")
  var methodNames = [haveSetUp ? "setUp" : "failed", test.name, "failed"]
  var methodIDs = methodNames.map(name => methodID({ name }))
  var stdio = ["pipe", "pipe", "inherit"]
  var child = require("child_process").spawn("ethrun", methodIDs, { stdio })
  var output = []
  child.stdout.on("data", x => output.push(x))
  child.stdout.on("end", () => handleTestOutput(test, Buffer.concat(output)))
  child.stdin.end([
    ...extraBytecode,
    test.class.bytecode,
  ].map(x => `${x}\n`).join(""))
}

function formatTable(rows) {
  var ls = new Array(rows[0] && rows[0].length);
  // compute the max length of every colon
  rows.forEach(row => row.forEach((col, i) => {
    if(!ls[i] || ls[i] < col.length) ls[i] = col.length;
  }));

  const leftPad = (c, l) => (l <= 0)? c : c + leftPad(c, l-1);

  return "<table>" + rows.map(row => "<tr>"+row.map((col, i) => `<td> ${col+leftPad(" ", ls[i]-col.length)}</td>`).join("\n")).join("</tr>\n<tr>") + "</tr></table>";

}

function handleTestOutput(test, output) {
  test.finished = true
  test.results = JSON.parse(output)

  var els = {};
  var drawlogs = []
  var draw;

  const formatterLogPrefix = "omfgThoseDappHubGuysAreAwesome_";

  const eventTypes = [
    "li", "ul", "h1", "h2", "h3", "h4", "h5", "h6",
    "b", "div", "a", "table", "tr", "td", "th", "graph"
  ];

  const eventTopics = eventTypes
    .reduce((o, v) => (o[sha3(v).toString("hex")] = v) && o, {});

  test.results.forEach(action => {
    action.logs.forEach(log => {

      var event = getEvent(log.topics[0])
      if (event) {
        var params = [
          ...event.inputs.filter(x =>  x.indexed),
          ...event.inputs.filter(x => !x.indexed),
        ]

        // console.log(event.name, params);
        var args = ethabi.rawDecode(
          params.map(x => x.type),
          new Buffer(log.topics.slice(1).join("") + log.data, "hex")
        )
        if(new RegExp(`^${formatterLogPrefix}`).test(event.name)) {
          var logattr = {};
          params
          .forEach((value, i) => {
            logattr[value.name] = Object.assign({}, value, {
              value: (Buffer.isBuffer(args[i])
                ? "0x" + args[i].toString("hex")
                : args[i])
            })
          });

          drawlogs.push({
            name: event.name.slice(formatterLogPrefix.length),
            params: logattr
          })
        }


        // if(event.name === `${formatterLogPrefix}draw`) {
        //   draw = args[0];
        // } else if((new RegExp(`^${formatterLogPrefix}`)).test(event.name)) {
        //   if(!els[args[0]]) {
        //     els[args[0]] = {
        //       type: event.name,
        //       args: args.slice(1),
        //       _id: args[0]
        //     }
        //   } else {
        //     els[args[0]].args = els[args[0]].args.concat(args.slice(1));
        //   }
        // } else {
        //   console.log("no", event.name);
        // }

      } else if(log.topics[0] in eventTopics) {
        drawlogs.push({
          name: eventTopics[log.topics[0]],
          direct: true,
          params: {
            _id: {
              value: "0x" + log.topics[1].toString("hex")
            },
            children: {value: log.data.length === 0
            ? "0x" + log.topics[1].toString("hex")
            : log.data.match(/.{1,64}/g).map(e => "0x" + e)
            }
          }
        })
      } else {
        console.log(log);
      }
    })
  })
  // console.log(JSON.stringify(drawlogs, false, 2));

  // var evalDOM = function (_id) {
  //   let match = (new RegExp(`^${formatterLogPrefix}(.*)$`))
  //     .exec(els[_id].type);
  //   let type = match && match[1] || "";
  //   if(type === "text") {
  //     return { type,
  //       args: {value: els[_id].args[0]},
  //       children: []
  //     };
  //   } else if(type === "node") {
  //     return { type,
  //       args: {
  //         graphId: els[_id].args[0].toString("hex"),
  //         id: els[_id].args[1].toString("hex"),
  //         label: els[_id].args[2]
  //       },
  //       children: []
  //     };
  //   } else if(type === "tnode") {
  //     return { type,
  //       args: {
  //         graphId: els[_id].args[0].toString("hex"),
  //         id: els[_id].args[1].toString("hex"),
  //       },
  //       children: [evalDOM(els[_id].args[2])]
  //     };
  //   } else if(type === "edge") {
  //     return { type,
  //       args: {
  //         graphId: els[_id].args[0].toString("hex"),
  //         idA: els[_id].args[1].toString("hex"),
  //         idB: els[_id].args[2].toString("hex"),
  //         params: 2 in els[_id].args && els[_id].args[3] || ""
  //       },
  //       children: []
  //     };
  //   } else if(type === "graph") {
  //     return { type,
  //       args: {},
  //       children: Object.values(els)
  //       .filter(e => {
  //         return e.args[0].toString("hex") == _id.toString("hex")
  //       })
  //       .map(e =>  evalDOM(e._id))
  //     };
  //   } else if(type !== "") {
  //     return { type,
  //       args: {},
  //       children: els[_id].args.map(_id => evalDOM(_id))
  //     };
  //   }
  // }

  test.drawlogs = drawlogs;
  // console.log(JSON.stringify(drawlogs, false, 2));

  test.failed = !!Number(test.results.slice(-1)[0].output)
  test.passed = test.results.every(x => x.success) && !test.failed

  test.inverted = /^test(Fail|Error)/.test(test.name)
  test.passed = test.inverted ? !test.passed : test.passed

  if (tests.every(test => test.finished && (printProgress(test), true))) {
    printDetails()
    printSummary()

    if (tests.some(x => !x.passed)) {
      process.exit(1)
    }
  }
}

function printProgress(test) {
  if (!test.printed) {
    test.printed = true
    process.stdout.write(test.passed ? "." : "\x1b[31;1mF\x1b[0m")
  }
}

function printDetails() {
  console.log()

  failures = tests.filter(test => !test.passed)
  failures.forEach(printFailure)
}

function printFailure(failedTest) {
  console.log()

  addressNames[failedTest.results[0].trace[0].action.from] = "Dapp"
  addressNames[failedTest.results[0].trace[0].result.address] = failedTest.class.name

  var name = failures.every(x => x.class.name == failedTest.class.name)
    ? failedTest.name : `${failedTest.class.name}.${failedTest.name}`

  // XXX side effects
  failedTest.results.forEach(x => x.trace.forEach(formatTrace))

  var crash = !failedTest.failed && !failedTest.inverted

  console.log([
    `\x1b[31;1m${
      crash ? "[CRASH]" : failedTest.failed ? "[FAIL]" : "[NOFAIL]"
    }\x1b[0m \x1b[4m${name}\x1b[0m`,
    ([].concat(...failedTest.results.map(result => {
      var lastAddress = result.trace[result.trace.length - 1].trace_address
      return [
        ...result.logs.map(formatLog).filter(x => x),
        ...(crash && !result.success ? [result.trace.filter(
          trace => trace.trace_address.length <= lastAddress.length && (
            true //trace.trace_address.every((x, i) => x <= lastAddress[i])
          )
        ).map(formatTrace).filter(x => x)].map(traces => {
          var length = Math.max(...traces.map(x => x.sender.length))
          return traces.map(x => `${lpad(x.sender, length)} -> ${x.message}`)
        })[0] : []),
      ]
    })).join("\n") || "(no details)").replace(/^/gm, "  "),
  ].join("\n").replace(/^/gm, "  "))
}

function formatAddress(address) {
  return addressNames[address] || `<${address.slice(0, 4)}>`
}

function formatMethodID(id) {
  return id in methods ? formatMethod(methods[id]) : id
}

function formatValue(type, value) {
  if (type == "bytes4" && value.toString("hex") in methods) {
    var method = methods[value.toString("hex")]
    var inputs = method.inputs || []
    return `bytes4(keccak(${JSON.stringify(`${method.name}(${
      inputs.map(({ type }) => getCanonicalTypeName(type)).join(",")
    })`)}))`
  } else if (type == "address") {
    return formatAddress(value.toString("hex"))
  } else if (value instanceof Buffer) {
    return `0x${value.toString("hex")}`
  } else if (/^u?int\d+$/.test(type)) {
    value = new BigNumber(value.toString())
    if (value.lt(1e12)) {
      return value.toFixed(0)
    } else if (value.gt(1e14) && value.lt(1e25)) {
      return `${value.dividedBy(new BigNumber("1e18"))} ether`
    } else if (value.gt(1e26) && value.lt(3.4e38)) {
      return value
    } else {
      return `0x${value.toString(16)}`
    }
  } else {
    return JSON.stringify(value)
  }
}

function formatMethodCall(data) {
  var [id, data] = [data.slice(0, 8), data.slice(8)]
  var method = methods[id]
  return method ? `${method.name}(${ethabi.rawDecode(
    (method.inputs || []).map(x => x.type), new Buffer(data, "hex")
  ).map((x, i) => formatValue(method.inputs[i].type, x)).join(", ")})`
  : `<${id}>(0x${data})`
}

function formatMethodOutput(id, data) {
  return !(id in methods) ? `0x${data}` : `(${ethabi.rawDecode(
    (methods[id].outputs || []).map(x => x.type), new Buffer(data, "hex")
  ).map((x, i) => formatValue(methods[id].outputs[i].type, x)).join(", ")})`
}

function formatTrace(trace) {
  var indent = trace.trace_address.map(x => "  ").join("")
  if (trace.action.type == "call") {
    return { sender: formatAddress(trace.action.from), message: `${indent}${formatAddress(trace.action.to)}${trace.action.input.length % 64 == 8 ? `.${formatMethodCall(trace.action.input)}` : `(${trace.action.input})`} => ${"output" in trace.result ? formatMethodOutput(trace.action.input.slice(0, 8), trace.result.output) : trace.result.error ? `\x1b[31;1m${trace.result.error}\x1b[0m` : JSON.stringify(trace.result)}` }
  } else if (trace.action.type == "create") {
    var classname = `<${keccak(trace.action.init).slice(0, 6)}>`
    if (trace.result.code) {
      var codehash = keccak(trace.result.code)
      classname = codehash in classes
        ? classes[codehash].name
        : `<${codehash.slice(0, 6)}>`
      addressNames[trace.result.address] = `<${classname}#${trace.result.address.slice(0, 4)}>`
    }

    return { sender: formatAddress(trace.action.from), message: `${indent}new ${classname}(...) => ${trace.result.error || formatAddress(trace.result.address) || JSON.stringify(trace.result)}` }
  }
}

function formatLog(log) {
  var event = getEvent(log.topics[0])
  if (event) {
    var params = [
      ...event.inputs.filter(x =>  x.indexed),
      ...event.inputs.filter(x => !x.indexed),
    ]

    var args = ethabi.rawDecode(
      params.map(x => x.type),
      new Buffer(log.topics.slice(1).join("") + log.data, "hex")
    )

    if (event.name == "log_bytes32") {
      return toString(args[0]).replace(
        /^Error: /, "\x1b[31;1mError:\x1b[0m "
      )
    } else if (/^log_named_bytes32$/.test(event.name)) {
      return `${args[0]}: ${formatBytes(args[1])}`
    } else if (/^log_named_u?int$/.test(event.name)) {
      return `${args[0]}: ${new BigNumber(String(args[1]))}`
    } else if (/^log_named_decimal_u?int$/.test(event.name)) {
      var number = new BigNumber(String(args[1]))
      var decimals = Number(args[2])
      var scale = new BigNumber(`1e${decimals}`)
      var formattedNumber = number.div(scale).toFormat(decimals)
      return `${args[0]}: ${lpad(formattedNumber, decimals + 6)}`
    } else if (verbose) {
      return `\x1b[36m${event.name}(${args.map((arg, i) => {
        return ({
          address : formatBinary,
          bytes32 : formatBytes,
          string  : formatString,
        }[params[i].type] || (x => x))(arg)
      }).join(", ")})\x1b[0m`
    }
  } else {
    return `\x1b[36m ${
      JSON.stringify(log.topics)
    } ${JSON.stringify(log.data)}\x1b[0m`
  }
}

function formatBytes(x) {
  return isPrintable(x) ? formatString(x) : formatBinary(x)
}

function formatBinary(x) {
  return `0x${x.toString("hex")}`
}

function isPrintable(x) {
  return !/\0/.test(toString(x))
}

function lpad(x, n) {
  return padding(x, n) + x
}

function rpad(x, n) {
  return x + padding(x, n)
}

function padding(x, n) {
  return new Array(Math.max(0, n - x.length) + 1).join(" ")
}

function toString(x) {
  return String(x).replace(/\0+$/, "")
}

function formatString(x) {
  return JSON.stringify(toString(x))
}

function getEvent(topic) {
  return events.filter(event => eventID(event) == topic)[0]
}

function printSummary() {
  require("fs").writeFileSync(`out/eval.json`, JSON.stringify(tests, false, 2), "utf8");
  // console.log(JSON.stringify(tests, false, 2));
  // var failures = tests.filter(x => !x.passed)
  // var passed = tests.length - failures.length
  // console.log()
  // console.log(`${passed} tests passed, ${failures.length} failed`)
  // console.log(`Took ${((new Date - t0) / 1000).toFixed(3)}s`)
}

function getTests() {
  return getTestMethods().map((testMethod, index) => {
    return Object.assign({ index }, testMethod)
  })
}

function getTestClasses() {
  return getClasses().filter(x => x.members.some(isTestMethod))
}

function getTestMethods() {
  return sortMembers([].concat(
    ...getTestClasses().map(testClass => {
      return testClass.members.filter(isTestMethod).map(testMethod => {
        return Object.assign({ class: testClass }, testMethod)
      })
    })
  ))
}

function isTestMethod({ name, inputs }) {
  return testRegex.test(name) && inputs.length == 0
}

function sortMembers(members) {
  return members.sort(alphabetizeMembers).sort(orderMembers)
}

function alphabetizeMembers(a, b) {
  return a.name > b.name ? +1 : a.name < b.name ? -1 : 0
}

function orderMembers(a, b) {
  return localSourceCode.indexOf(a.name) - localSourceCode.indexOf(b.name)
}

function methodID(method) {
  var result = ethabi.methodID(
    method.name, (method.inputs || []).map(x => x.type)
  ).toString("hex")
  methods[result] = method
  return result
}

function eventID({ name, inputs }) {
  return ethabi.eventID(name, inputs.map(x => x.type)).toString("hex")
}

function getLocalSourceCode() {
  return require("child_process").execSync(`
    dir=$({ grep 2>/dev/null sol_sources: [Dd]appfile; } | awk '{print $2}')
    find "\${dir:-.}" -name '*.sol*' | sort | xargs cat
  `, { encoding: "utf-8", stdio: [null, "pipe", "inherit"] })
}

function getClass({ name, bytecode, runtimeBytecode, abi }) {
  var result = {
    name, bytecode, runtimeBytecode,
    members: abi.map(member => {
      if (member.type == "function") {
        member.methodID = methodID(member)
      }
      return member
    }),
  }
  classes[keccak(runtimeBytecode)] = result
  return result
}

function getClasses() {
  if (classesJSON.contracts) {
    return Object.keys(classesJSON.contracts).map(name => {
      var abi = classesJSON.contracts[name]["abi"]
      var bytecode = classesJSON.contracts[name]["bin"]
      var runtimeBytecode = classesJSON.contracts[name]["bin-runtime"]

      if (abi == null || bytecode == null) {
        console.error(`${PROGRAM_NAME}: please add --combined-json=abi,bin`)
        process.exit(1)
      }

      abi = JSON.parse(abi)

      return getClass({ name, bytecode, runtimeBytecode, abi })
    })
  } else {
    return Object.keys(classesJSON).map(name => {
      var bytecode = classesJSON[name].bytecode
      var runtimeBytecode = classesJSON[name].runtimeBytecode
      var abi = JSON.parse(classesJSON[name].interface)
      return getClass({ name, bytecode, runtimeBytecode, abi })
    })
  }
}

function getCanonicalTypeName(name) {
  if (name.startsWith("int[")) {
    return "int256" + name.slice(3)
  } else if (name === "int") {
    return "int256"
  } else if (name.startsWith("uint[")) {
    return "uint256" + name.slice(4)
  } else if (name === "uint") {
    return "uint256"
  } else if (name.startsWith("fixed[")) {
    return "fixed128x128" + name.slice(5)
  } else if (name === "fixed") {
    return "fixed128x128"
  } else if (name.startsWith("ufixed[")) {
    return "ufixed128x128" + name.slice(6)
  } else if (name === "ufixed") {
    return "ufixed128x128"
  }
  return name
}
